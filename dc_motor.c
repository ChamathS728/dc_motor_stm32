#include "dc_motor.h"


/* Initialisation functions */
DC_MTR* DC_MOTOR_init(TIM_HandleTypeDef* PWM_timer,
                   TIM_HandleTypeDef* ENC_timer,
                   uint32_t PWM_channel,
                   uint32_t encoder_channel,
                   GPIO_TypeDef* encA_port,
                   uint16_t encA_pin,
                   GPIO_TypeDef* encB_port,
                   uint16_t encB_pin,
                   uint16_t PWM_freq_min,
                   uint16_t PWM_freq_max,
                   GPIO_TypeDef* DIR_port,
                   uint16_t DIR_pin);
{
    // Initialise a struct
    DC_MTR* dc_motor = NULL;

    dc_motor->PWM_timer = PWM_timer;
    dc_motor->ENC_timer = ENC_timer;
    dc_motor->PWM_channel = PWM_channel;
    dc_motor->encoder_channel = encoder_channel;
    dc_motor->encA_port = encA_port;
    dc_motor->encA_pin = encA_pin;
    dc_motor->encB_port = encB_port;
    dc_motor->encB_pin = encB_pin;

    dc_motor->PWM_freq_min = PWM_freq_min;
    dc_motor->PWM_freq_max = PWM_freq_max;

    dc_motor->lastPWM = 0;
    

    #ifndef ABSTRACT
        // NOTE: only do this if we want as much code abstracted as possible
        // Init function should be after MX_TIM_INIT has been called from autogenerated code
        
        // Start the encoder timer itself
        HAL_TIM_Encoder_Start(ENC_timer, TIM_CHANNEL_ALL);

        // Start the PWM timer
        HAL_TIM_PWM_Start(PWM_timer, PWM_channel); // eg: do TIM_CHANNEL_1 for Channel 1 PWM generation

    #endif

    // Set the zero for the encoder upon initialisation by reading the current counter
    dc_motor->encZero = (ENC_timer->CNT) >> 2;

    return dc_motor;
}                   


void DC_MTR_setDutyCycle(DC_MTR* dc_mtr_ptr, float duty_cycle) {
	if (duty_cycle > 100) duty_cycle = 100;
	if (duty_cycle < 0) duty_cycle = 0;

	float pw_resolution = (((float)(*(dc_mtr_ptr->PWM_timer)).Init.Period + 1.0f) / 100.0f);

	uint16_t pw_desired = pw_resolution * duty_cycle;
	__HAL_TIM_SET_COMPARE(dc_mtr_ptr->PWM_timer, dc_mtr_ptr->ENC_timer, pw_desired); 

    /*
    // Alternative implementation, not validated
    // Assumes that Timer 2 Channel 1 is used, with an ARR of 4 294 967 295
    if (duty_cycle > 100) duty_cycle = 100;
	if (duty_cycle < 0) duty_cycle = 0;

    TIM2->CCR1 = (duty_cycle * 4294967295)/100;
    */
}

void DC_MTR_setDIR(DC_MTR* dc_mtr_ptr, int DIR_state) {
    HAL_GPIO_WritePin(dc_mtr_ptr->DIR_port, dc_mtr_ptr->DIR_pin, DIR_state);
}
void DC_MTR_swapDIR(DC_MTR* dc_mtr_ptr) {
    // Toggle the direction pin
    HAL_GPIO_TogglePin(dc_mtr_ptr->DIR_port, dc_mtr_ptr->DIR_pin);
}

// void DC_MTR_setPWMFreq(DC_MTR* dc_mtr_ptr, float frequency) {
//     /*
//     F_PWM = F_CLK / ((ARR + 1) x (PSC + 1))
//     Solving for ARR assuming the prescaler PSC and clock frequency F_CLK is set

//     ARR = F_CLK/(F_PWM x (PSC + 1)) - 1
//     */
//     TIM2->ARR = (TIM2->F_CLK)/(frequency * (TIM2->PSC + 1)) - 1;

// }

// Encoder commands
int DC_MTR_getDIR(DC_MTR* dc_mtr_ptr) {
    if (__HAL_TIM_IS_TIM_COUNTING_DOWN(*(dc_mtr_ptr->ENC_timer))) {
        return 0;
    }
    else {
        return 1;
    }
}